<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Dynamic Form - Editor and Preview</title>
  <style>
    /* Existing editor styles (remain the same) */
    :root {
      --main-color: #003cff;
      --accent: var(--main-color);
      --light-gray: #f8f9fa;
      --border-color: #dadce0;
      --text-color: #202124;
      --secondary-text: #5f6368;
    }

    body {
      font-family: 'Roboto', 'Segoe UI', Arial, sans-serif;
      background: #f8f9fa;
      margin: 0;
      padding: 20px;
      color: var(--text-color);
    }

.view-toggle {
  max-width: 600px;         /* same as form */
  margin: 0 auto 10px;      /* centered */
  display: flex;
  justify-content: flex-end; /* pushes button to the right */
}

.view-toggle button {
  padding: 6px 12px;        /* smaller */
  font-size: 13px;
  border: 1px solid #ccc;
  border-radius: 6px;
  cursor: pointer;
  background: #fff;
}


    .view-toggle button.active {
      background: var(--main-color);
      color: white;
      border-color: var(--main-color);
    }

    .editor-view, .preview-view {
      display: none;
    }

    .editor-view.active, .preview-view.active {
      display: block;
    }

    /* Editor styles (remain the same) */
    .controls {
      max-width: 800px;
      margin: 0 auto 16px;
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      align-items: center;
    }

    .controls button, .controls input[type="color"] {
      padding: 6px 12px;
      border: 1px solid #ccc;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      background: #fff;
    }

    .controls label { font-size: 14px; color: #444; }

    .form-container {
      max-width: 800px;
      margin: auto;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      padding: 0;
      overflow: hidden;
    }

    .logo-config {
      padding: 24px 24px 0;
      border-bottom: 1px solid var(--border-color);
    }

    .logo-input-container {
      display: flex;
      align-items: center;
      gap: 16px;
      margin-bottom: 16px;
    }

    .logo-preview {
      width: 100px;
      height: 60px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      background: var(--light-gray);
    }

    .logo-preview img {
      max-width: 100%;
      max-height: 100%;
    }

    .logo-input {
      flex: 1;
      padding: 8px 12px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-size: 14px;
    }

    .form-header {
      border-top: 8px solid var(--main-color);
      padding: 24px;
      border-bottom: 1px solid var(--border-color);
      position: relative;
    }

    .form-title {
      width: 100%;
      font-size: 28px;
      font-weight: normal;
      border: none;
      outline: none;
      color: var(--text-color);
      margin-bottom: 12px;
      background: transparent;
      font-family: inherit;
      cursor: text;
    }

    .form-description {
      width: 100%;
      font-size: 14px;
      border: none;
      outline: none;
      color: var(--secondary-text);
      resize: none;
      background: transparent;
      font-family: inherit;
      min-height: 60px;
      cursor: text;
    }

    .closing-message {
      padding: 16px 24px;
      border-top: 1px solid var(--border-color);
      background: #f9f9f9;
    }

    .closing-title {
      font-size: 16px;
      font-weight: 500;
      margin-bottom: 8px;
      color: var(--text-color);
    }

    .closing-textarea {
      width: 100%;
      min-height: 80px;
      padding: 12px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-family: inherit;
      font-size: 14px;
      resize: vertical;
    }

    /* Existing styles for question blocks, etc. */
    .question-block, .text-block, .image-block {
      padding: 24px;
      border-bottom: 1px solid var(--border-color);
      background: #fff;
      position: relative;
    }

    .question-block.dragging, .section-block.dragging, .text-block.dragging, .image-block.dragging {
      opacity: 0.5;
    }

    .question-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }

    .question-input {
      flex-grow: 1;
      font-size: 16px;
      border: none;
      border-bottom: 1px solid transparent;
      padding: 8px 0;
      outline: none;
      background: transparent;
      font-family: inherit;
      cursor: text;
    }

    .question-input:focus {
      border-bottom: 1px dashed var(--border-color);
    }

    .type-select {
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 6px 8px;
      font-size: 14px;
      margin-left: 16px;
      font-family: inherit;
      color: var(--secondary-text);
    }

    .required-toggle {
      margin-left: auto;
      font-size: 14px;
      color: var(--secondary-text);
      display: flex;
      align-items: center;
      gap: 8px;
      user-select: none;
    }

    .question-body {
      margin-left: 24px;
    }

    .short-answer-text {
      padding-bottom: 8px;
      color: var(--secondary-text);
      font-size: 14px;
    }

    .short-answer-input, .paragraph-input {
      width: 100%;
      padding: 8px 0;
      border: none;
      border-bottom: 1px solid var(--border-color);
      outline: none;
      font-size: 14px;
      font-family: inherit;
      background: transparent;
      resize: vertical;
      min-height: 24px;
    }

    .question-footer {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid var(--border-color);
    }

    .action-buttons {
      display: flex;
      gap: 8px;
    }

    .action-btn {
      background: none;
      border: none;
      cursor: pointer;
      color: #5f6368;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 8px;
      border-radius: 50%;
      transition: background-color 0.2s;
    }

    .action-btn:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }

    .delete-btn {
      background: none;
      border: none;
      color: #d93025;
      font-size: 20px;
      cursor: pointer;
      padding: 8px;
      border-radius: 50%;
      transition: background-color 0.2s;
    }

    .delete-btn:hover {
      background-color: rgba(217, 48, 37, 0.1);
    }

    .options {
      margin-top: 16px;
    }

    .option {
      display: flex;
      align-items: center;
      margin: 8px 0;
      color: var(--text-color);
      gap: 8px;
    }

    .option input[type="radio"],
    .option input[type="checkbox"] {
      accent-color: var(--accent);
    }

    .option-text {
      border: none;
      border-bottom: 1px dashed #ccc;
      outline: none;
      padding: 4px 0;
      flex: 1;
      font-family: inherit;
      font-size: 14px;
      background: transparent;
      cursor: text;
    }

    .add-option {
      margin-top: 8px;
      font-size: 14px;
      color: #1a73e8;
      cursor: pointer;
      user-select: none;
      display: inline-block;
    }

    .add-option:hover { text-decoration: underline; }

    .footer {
      padding: 16px 24px;
      text-align: right;
      border-top: 1px solid var(--border-color);
    }

    .submit-btn {
      background: var(--main-color);
      color: #fff;
      border: none;
      padding: 10px 24px;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      font-family: inherit;
    }

    .submit-btn:hover { filter: brightness(0.95); }

    /* Sidebar */
    .sidebar {
      position: fixed;
      top: 100px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .sidebar button {
      width: 40px;
      height: 40px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #fff;
      cursor: pointer;
      font-size: 18px;
      transition: background-color 0.2s;
    }

    .sidebar button:hover { background: #f1f3f4; }

    /* Section block */
    .section-block {
      padding: 20px;
      margin: 32px 0;
      background: #f1f3f4;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      cursor: grab;
    }

    .section-title {
      width: 100%;
      font-size: 20px;
      font-weight: bold;
      border: none;
      outline: none;
      background: transparent;
      margin-bottom: 10px;
      font-family: inherit;
      cursor: text;
    }

    .section-description {
      width: 100%;
      font-size: 14px;
      border: none;
      outline: none;
      background: transparent;
      color: var(--secondary-text);
      resize: none;
      font-family: inherit;
      cursor: text;
    }

    .required-field {
      border-left: 3px solid #d93025 !important;
    }

    .error-message {
      color: #d93025;
      font-size: 12px;
      margin-top: 4px;
      display: none;
    }

    .toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: #333;
      color: white;
      padding: 12px 20px;
      border-radius: 4px;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .toast.show {
      opacity: 1;
    }

    .name-display {
      display: none; /* We hide the name display */
    }

    .placeholder-input {
      width: 100%;
      padding: 8px;
      margin: 8px 0;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }

    .tutorial-note {
      font-size: 12px;
      color: #5f6368;
      font-style: italic;
      margin-top: 4px;
    }

    .validation-status {
      margin-top: 10px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 4px;
      font-size: 14px;
    }

    .status-ok {
      color: #0f9d58;
      border-left: 3px solid #0f9d58;
    }

    .status-error {
      color: #d93025;
      border-left: 3px solid #d93025;
    }

    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }

    .spinner {
      width: 40px;
      height: 40px;
      border: 4px solid #f3f3f3;
      border-top: 4px solid var(--main-color);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* New styles for rich text editors */
    .rich-text-editor {
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 8px;
      min-height: 100px;
      margin-top: 8px;
      font-family: inherit;
    }

    .rich-text-editor:focus {
      outline: none;
      border-color: var(--main-color);
    }

    .format-toolbar {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
    }

    .format-btn {
      background: none;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 4px 8px;
      cursor: pointer;
      font-size: 14px;
    }

    .format-btn:hover {
      background-color: #f1f3f4;
    }

    .format-btn.active {
      background-color: #e6f2ff;
      border-color: var(--main-color);
    }

    /* Styles for formatted editable content */
    [contenteditable=true] {
      outline: none;
      min-height: 60px;
      padding: 8px;
      border: 1px solid #eee;
      border-radius: 4px;
    }

    [contenteditable=true]:focus {
      border-color: #ccc;
    }
    
    /* Drag indicator */
    .drag-handle {
      cursor: grab;
      padding: 8px;
      color: #5f6368;
      user-select: none;
    }
    
    .drag-handle:active {
      cursor: grabbing;
    }

    /* Preview styles */
    .preview-logo-container {
            width: 600px;
            margin-bottom: 20px;
            text-align: center;
            box-sizing: border-box;
            margin: 0 auto 20px; /* centers horizontally and adds bottom margin */
            
    }

    .preview-logo-container img {
            width: 600px;
            height: auto;
            border-radius: 8px;
            object-fit: contain;
    }

    .preview-form-container {
            width: 600px;
            background-color: #fff;
            border: 1px solid var(--border-color);
            border-top: 8px solid var(--main-color);
            border-radius: 8px;
            box-shadow: 0px 3px 8px rgba(0, 0, 0, 0.1);
            box-sizing: border-box;
            padding: 22px;
            margin-bottom: 20px;
            margin: 0 auto 20px; /* centers horizontally and adds bottom margin */
    }

    .preview-form-container2 {
            width: 600px;
            background-color: #fff;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0px 3px 8px rgba(0, 0, 0, 0.1);
            box-sizing: border-box;
            padding: 32px;
            margin-bottom: 20px;
            position: relative;
            margin: 0 auto 20px; /* centers horizontally and adds bottom margin */
    }

    .preview-form-container3 {
            max-width: 600px;
            width: 100%;
            box-sizing: border-box;
            padding: 0px;
            margin-bottom: 20px;
            margin: 0 auto 20px; /* centers horizontally and adds bottom margin */
    }

    .preview-question-container {
      margin-bottom: 32px;
    }

    .preview-title {
      font-size: 28px;
      font-weight: bold;
      color: var(--text-color);
      margin-bottom: 12px;
      text-align: center;
      line-height: 1.3;
    }
    
    .preview-warning {
      font-size: 14px;
      font-weight: bold;
      color: var(--error-color);
      margin-top: 8px;
      padding: 8px 12px;
      background-color: #fce8e6;
      border-radius: 4px;
      border-left: 4px solid var(--error-color);
      display: none;
    }

    .preview-question {
      font-size: 18px;
      font-weight: bold;
      color: var(--text-color);
      margin-bottom: 12px;
      line-height: 1.4;
    }
    
    .preview-textblock {
      font-size: 16px;
      color: var(--text-color);
      line-height: 1.6;
      margin-bottom: 12px;
      padding: 12px;
      background-color: #f9f9f9;
      border-radius: 4px;
    }

    .preview-input-container {
      margin-bottom: 24px;
    }

    .preview-input, .preview-textarea, .preview-select {
      width: calc(100% - 24px);
      padding: 12px;
      box-sizing: border-box;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-size: 16px;
      margin-top: 8px;
      transition: border-color 0.3s, box-shadow 0.3s;
      font-family: 'Roboto', sans-serif;
    }

    .preview-input:focus, .preview-textarea:focus, .preview-select:focus {
      border-color: var(--main-color);
      box-shadow: 0 0 0 2px rgba(0, 60, 255, 0.2);
      outline: none;
    }

    .preview-textarea {
      min-height: 100px;
      resize: vertical;
    }

    .preview-button {
      background-color: var(--main-color);
      color: white;
      padding: 12px 20px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 500;
      transition: background-color 0.3s, transform 0.2s;
      display: block;
      margin: 0 auto;
      min-width: 150px;
    }

    .preview-button:hover {
      background-color: #0028cc;
      transform: translateY(-2px);
    }

    .preview-button:active {
      transform: translateY(0);
    }
     
    .preview-canvas {
      width: 100%;
      height: auto;
      aspect-ratio: 5 / 3;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      touch-action: none;
      display: block;
      background-color: #f9f9f9;
    }

    .preview-input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
      margin-right: 8px;
    }

    .preview-radio-group, .preview-checkbox-group {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 16px;
      font-size: 16px;
    }

    .preview-radio-group label, .preview-checkbox-group label {
      display: flex;
      align-items: center;
      cursor: pointer;
    }

    .preview-radio-group input[type="radio"] {
      width: 18px;
      height: 18px;
      margin-right: 8px;
      cursor: pointer;
    }

    .preview-signature-info {
      margin-bottom: 12px;
      line-height: 1.5;
    }

    .preview-error-message {
      color: var(--error-color);
      background-color: #fce8e6;
      padding: 12px;
      border-radius: 4px;
      margin: 10px 0;
      display: none;
      max-width: 100%;
      width: 100%;
      box-sizing: border-box;
    }
    
    .preview-description-container {
      font-size: 16px;
      line-height: 1.6;
      color: #444;
    }
    
    .preview-description-container ul {
      padding-left: 20px;
      margin: 12px 0;
    }
    
    .preview-description-container li {
      margin-bottom: 8px;
    }
    
    .preview-thanks-container {
      text-align: center;
      padding: 30px;
      background-color: #f5f5f5;
      border-radius: 8px;
      margin-top: 20px;
    }
    
    .preview-thanks-title {
      font-size: 24px;
      color: #4caf50;
      margin-bottom: 15px;
      font-weight: bold;
    }
    
    .preview-thanks-message {
      font-size: 16px;
      margin-bottom: 20px;
      line-height: 1.5;
    }
    
    .preview-back-button {
      background: none;
      color: var(--main-color);
      border: none;
      text-decoration: underline;
      cursor: pointer;
      padding: 0;
      font-size: 16px;
      font-weight: 500;
    }
    
    .preview-required-marker {
      color: var(--error-color);
    }

    /* Modal background */
.password-modal {
  display: none; /* hidden by default */
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: rgba(0,0,0,0.5);
  justify-content: center;
  align-items: center;
  z-index: 2000;
}

/* Content */
.password-modal-content {
  background: #fff;
  padding: 20px 30px;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  text-align: center;
  max-width: 300px;
  width: 100%;
}

.password-modal-content h3 {
  margin-top: 0;
  margin-bottom: 15px;
}

.password-modal-content input {
  width: 100%;
  padding: 8px;
  margin-bottom: 12px;
  border: 1px solid #ccc;
  border-radius: 4px;
}

.modal-buttons {
  display: flex;
  justify-content: space-between;
  gap: 10px;
}

.modal-buttons button {
  flex: 1;
  padding: 8px 0;
  cursor: pointer;
  border: none;
  border-radius: 4px;
  background: #003cff;
  color: #fff;
}

.modal-buttons button:hover {
  filter: brightness(0.9);
}

.password-error {
  color: #d93025;
  font-size: 13px;
  display: none;
  margin-top: 8px;
}

  </style>
</head>
<body>
  <div class="loading-overlay" id="loadingOverlay">
        <div class="overlay-content">
            <div class="spinner"></div><br><br>
            <div class="loading-text">Loading...</div>
        </div>
  </div>

  <div class="view-toggle">

<button id="previewViewBtn" class="active" style="display: none;">Preview</button>
  <button id="editViewBtn">Admin</button>
  </div>

  <!-- Editor View -->
  <div id="editorView" class="editor-view">
    <div class="controls">
      <button style="display: none;" id="exportForm">Export JSON</button>
      <button style="display: none;" id="importForm">Import JSON</button>
      <label>Color: <input type="color" id="themeColor" value="#003cff" /></label>
    </div>
    <div class="form-container" id="formContainer">
      <!-- Section to configure the logo -->
      <div class="logo-config">
        <div class="logo-input-container">
          <div class="logo-preview" id="logoPreview">
            <span style="color: #999; font-size: 12px;">Logo preview</span>
          </div>
          <input type="text" class="logo-input" id="logoUrl" 
                 placeholder="Enter direct image URL for logo" 
                 value="https://i.ibb.co/3f1GNGW/Logo-Focus.jpg" />
        </div>
      </div>

      <div class="form-header">
        <input class="form-title" type="text" value="TEXT MESSAGING SERVICE AGREEMENT" placeholder="Form title" />
        <div class="format-toolbar">
          <button class="format-btn" data-command="bold" title="Bold">B</button>
        </div>
        <div class="rich-text-editor" id="formDescription" contenteditable="true" data-placeholder="Form description"></div>
      </div>

      <div id="questions">
        <!-- Initial block with new design -->
        <div class="question-block" data-type="text" data-name="text_1">
          <div class="drag-handle" title="Drag block">≡</div>
          <div class="question-header">
            <div class="format-toolbar">
              <button class="format-btn" data-command="bold" title="Bold">B</button>
            </div>
            <div class="rich-text-editor question-input" contenteditable="true" data-placeholder="Enter the question here"></div>
            <select class="type-select">
              <option value="text" selected>Short answer</option>
              <option value="radio">Multiple choice</option>
              <option value="checkbox">Checkboxes</option>
              <option value="dropdown">Dropdown</option>
              <option value="paragraph">Paragraph</option>
              <option value="date">Date</option>
              <option value="time">Time</option>
              <option value="signature">Signature</option>
            </select>
          </div>
          
          <div class="question-body">
            <input type="text" class="short-answer-input" placeholder="Enter your answer here">
            <div class="name-display">Field name: text_1</div>
            <div class="tutorial-note">Click on any text to edit it directly</div>
          </div>
          
          <div class="question-footer">
            <label class="required-toggle">
              <input type="checkbox" class="required-checkbox" checked /> Required
            </label>
            
            <div class="action-buttons">
              <button class="action-btn" title="Duplicate question" onclick="duplicateQuestion(this)">⎘</button>
              <button class="action-btn" title="Add image" onclick="addImageToQuestion(this)">🖼️</button>
              <button class="delete-btn" title="Delete block">🗑️</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Section for closing/thank you message -->
      <div class="closing-message">
        <div class="closing-title">Closing/Thank You Message</div>
        <div class="format-toolbar">
          <button class="format-btn" data-command="bold" title="Bold">B</button>
        </div>
        <div class="rich-text-editor" id="closingMessage" contenteditable="true" data-placeholder="Enter the message to display after form submission">Thank You! Your response has been successfully recorded.</div>
      </div>

      <div class="footer">
        <button class="submit-btn" type="button" id="sendToGoogle">Send to Google</button>
      </div>

      <!-- Validation status -->
      <div class="validation-status" id="validationStatus" style="display: none;"></div>
    </div>

    <div class="sidebar" id="sidebar">
      <button id="addQuestion" title="Add question">+</button>
      <button id="addText" title="Add text block">T</button>
      <button style="display: none;" id="addImage" title="Add image">🖼️</button>
      <button style="display: none;" id="addSection" title="Add section">≡</button>
    </div>

    <div class="toast" id="toast"></div>
  </div>

  <!-- Preview View -->
  <div id="previewView" class="preview-view active">
    <!-- Container for dynamic logo -->
    <div id="previewLogoContainer" class="preview-logo-container"></div>

    <!-- Container for header with title, description and thanks -->
    <div id="previewHeaderContainer" class="preview-form-container"></div>

    <!-- Error message -->
    <div id="previewErrorMessage" class="preview-error-message" style="display: none;"></div>

    <!-- Container for questions -->
    <div id="previewFormRoot"></div>

    <!-- Submit button -->
    <div class="preview-form-container3">
        <button type="button" id="previewSubmit" class="preview-button" onclick="previewSend()">Submit</button>
    </div>

    <!-- Loading overlay -->
    <div id="previewLoadingOverlay" style="display: none;">
        <div class="overlay-content">
            <div class="spinner"></div>
            <div class="loading-text">Loading...</div>
        </div>
    </div>
  </div>


  <!-- Password Modal -->
<div id="passwordModal" class="password-modal">
  <div class="password-modal-content">
    <h2>This part is just for the form owner. If that’s not you, feel free to just ignore it!</h2>
    <h3>Enter password</h3>
    <input type="password" id="passwordInput" placeholder="Password" />
    <div class="modal-buttons">
      <button id="passwordSubmit">Accept</button>
      <button id="passwordCancel">Cancel</button>
    </div>
    <div id="passwordError" class="password-error">Incorrect password</div>
  </div>
</div>


  <script>
    // URL to load configuration
    const CONFIG_URL = 'https://script.google.com/macros/s/AKfycbzGabnF9fDLLuqNTnonsyOuAR_liKKyF_bEKR95FGb4cJd3hxAPjjcPgsutAjv6dbaC/exec';
    const SUBMIT_URL = 'https://script.google.com/macros/s/AKfycbzGabnF9fDLLuqNTnonsyOuAR_liKKyF_bEKR95FGb4cJd3hxAPjjcPgsutAjv6dbaC/exec';
    
    // Default configuration (in case of error)
    const DEFAULT_CONFIG_STRING = `{
      "logoConfig": {
        "primaryColor": "#003cff",
        "logo": {
          "url": "https://i.ibb.co/3f1GNGW/Logo-Focus.jpg",
          "alt": "Company Logo"
        }
      },
      "titleConfig": {
        "id": "header-title",
        "title": "TEXT MESSAGING SERVICE AGREEMENT"
      },
      "descriptionConfig": {
        "id": "header-description",
        "descriptionHTML": ""
      },
      "thanksConfig": {
        "id": "header-thanks",
        "thanksHTML": "Thank You! Your response has been successfully recorded."
      },
      "questionsConfig": [
        {
          "type": "text",
          "name": "text_1",
          "text": "",
          "placeholder": "Enter your answer here",
          "required": true
        }
      ]
    }`;

    // Counters for automatic names
    const fieldCounters = {
      text: 1,
      radio: 1,
      checkbox: 1,
      dropdown: 1,
      paragraph: 1,
      date: 1,
      time: 1,
      slider: 1,
      signature: 1,
      textblock: 1
    };


function disableEditorInputs() {
  // All inputs and textareas in the editor
 /* document.querySelectorAll('#editorView input, #editorView textarea, #editorView select').forEach(el => {
    // Except those used to edit title/description/etc.
    if (!el.classList.contains('form-title') && !el.classList.contains('form-description')&& el.id !== 'themeColor') {
      el.setAttribute('disabled', 'true');
      el.setAttribute('readonly', 'true');
    }
  });

  // Signature canvases → block with CSS
  document.querySelectorAll('#editorView canvas').forEach(canvas => {
    canvas.style.pointerEvents = 'none';
  });*/
console.log("");
}

function enableEditorInputs() {
  document.querySelectorAll('#editorView input, #editorView textarea, #editorView select').forEach(el => {
    el.removeAttribute('disabled');
    el.removeAttribute('readonly');
  });

  document.querySelectorAll('#editorView canvas').forEach(canvas => {
    canvas.style.pointerEvents = 'auto';
  });
}


function showLoading() {
  document.getElementById("loadingOverlay").style.display = "flex";
}

function hideLoading() {
  document.getElementById("loadingOverlay").style.display = "none";
}


    // Global variables to store configuration
    let logoConfig, titleConfig, descriptionConfig, thanksConfig, questionsConfig;

    // ====== Load initial configuration ======
document.addEventListener('DOMContentLoaded', async function() {
  const loadingOverlay = document.getElementById('loadingOverlay');
  
  try {
    loadingOverlay.style.display = 'flex';
    const configData = await loadConfig();
    
    if (configData) {
      loadForm(configData); // ✅ generatePreview() ahora se llama dentro de loadForm()
      showToast('Configuration loaded successfully');
    }
  } catch (error) {
    console.error('Error loading configuration:', error);
    showToast('Error loading configuration. Using default configuration.', true);
    
    // Intentar con configuración por defecto
    try {
      const defaultConfig = JSON.parse(DEFAULT_CONFIG_STRING);
      loadForm(defaultConfig);
    } catch (parseError) {
      console.error("Error with default config:", parseError);
    }
  } finally {
    loadingOverlay.style.display = 'none';
    initLogo();
    initRichTextEditors();
    initImprovedDragSystem();
    setupViewToggle();
    // ❌ NO llamar generatePreview() aquí - ya se llama dentro de loadForm()
  }
});

    // ====== Configure view toggle buttons ======
    function setupViewToggle() {
      const editViewBtn = document.getElementById('editViewBtn');
      const previewViewBtn = document.getElementById('previewViewBtn');
      const editorView = document.getElementById('editorView');
      const previewView = document.getElementById('previewView');
    // Open modal instead of going directly  
      editViewBtn.addEventListener('click', () => {
        
    document.getElementById('passwordModal').style.display = 'flex';
    document.getElementById('passwordError').style.display = 'none';
    document.getElementById('passwordInput').value = '';
      });


        // Cancel button
  document.getElementById('passwordCancel').addEventListener('click', () => {
    document.getElementById('passwordModal').style.display = 'none';
  });


    // Accept button
  document.getElementById('passwordSubmit').addEventListener('click', () => {
    const input = document.getElementById('passwordInput').value.trim();
if (input === 'saving2025') {
  document.getElementById('passwordModal').style.display = 'none';
  editorView.classList.add('active');
  previewView.classList.remove('active');
  editViewBtn.classList.add('active');
  previewViewBtn.classList.remove('active');
   document.getElementById('previewViewBtn').style.display="block";
  
  disableEditorInputs(); // 🔴 disable response fields
}
else {
      // error
      document.getElementById('passwordError').style.display = 'block';
    }
  });

// Allow Enter in the input
document.getElementById('passwordInput').addEventListener('keyup', (e) => {
  if (e.key === 'Enter') {
    document.getElementById('passwordSubmit').click();
  }
});

  // Preview without password
  previewViewBtn.addEventListener('click', () => {
  editorView.classList.remove('active');
  previewView.classList.add('active');
  editViewBtn.classList.remove('active');
  previewViewBtn.classList.add('active');
  generatePreview();
  document.getElementById('previewViewBtn').style.display="none";
  enableEditorInputs(); // 🔵 restore if needed
});

    }


    // Genera la preview usando directamente la configuración (evita race con el DOM del editor)
function generatePreviewFromConfig(formData) {
  if (!formData) return;
  try {
    // Apply primary color safely
    applyPrimaryColor((formData.logoConfig && formData.logoConfig.primaryColor) || getComputedStyle(document.documentElement).getPropertyValue('--main-color').trim());

    // Load logo
    loadPreviewLogo((formData.logoConfig && formData.logoConfig.logo && formData.logoConfig.logo.url) || '', (formData.logoConfig && formData.logoConfig.logo && formData.logoConfig.logo.alt) || '');

    // Header
    createPreviewHeader("previewHeaderContainer", formData.titleConfig || {}, formData.descriptionConfig || {}, formData.thanksConfig || {});

    // Questions
    const previewFormRoot = document.getElementById("previewFormRoot");
    previewFormRoot.innerHTML = '';

    (formData.questionsConfig || []).forEach(questionConfig => {
      createPreviewQuestion("previewFormRoot", questionConfig);
    });

    console.info("Preview generada desde config (server).");
  } catch (err) {
    console.error("Error en generatePreviewFromConfig:", err);
    // Como fallback, intenta la generación normal
    generatePreview();
  }
}

// ====== Generate preview ======
function generatePreview() {
  // Get form data
  const formData = serializeForm();
  
  // Apply primary color
  applyPrimaryColor(formData.logoConfig.primaryColor);

  // Load logo
  loadPreviewLogo(formData.logoConfig.logo.url, formData.logoConfig.logo.alt);

  // Header
  createPreviewHeader("previewHeaderContainer", formData.titleConfig, formData.descriptionConfig, formData.thanksConfig);

  // Clear questions
  const previewFormRoot = document.getElementById("previewFormRoot");
  previewFormRoot.innerHTML = '';

  // Create questions
  formData.questionsConfig.forEach(questionConfig => {
    createPreviewQuestion("previewFormRoot", questionConfig);
  });

  // 🔄 Re-render de seguridad para evitar que falten opciones
  setTimeout(() => {
    const stillEmpty = [...document.querySelectorAll(".preview-radio-group, .preview-checkbox-group, .preview-select")]
      .some(el => el.children.length <= 1); // solo "Select an option" o vacío
    if (stillEmpty) {
      console.warn("⚠️ Algunas opciones no se cargaron, regenerando preview...");
      previewFormRoot.innerHTML = '';
      formData.questionsConfig.forEach(questionConfig => {
        createPreviewQuestion("previewFormRoot", questionConfig);
      });
    }
  }, 200);
}


    // ====== Function to apply primary color from JSON configuration ======
    function applyPrimaryColor(primaryColor) {
      const root = document.documentElement;
      
      // Calculate hover color (darken by 15%)
      const hoverColor = darkenColor(primaryColor, 15);
      
      root.style.setProperty('--main-color', primaryColor);
      root.style.setProperty('--primary-hover', hoverColor);
    }

    // ====== Function to darken a hexadecimal color ======
    function darkenColor(color, percent) {
      const num = parseInt(color.replace("#", ""), 16);
      const amt = Math.round(2.55 * percent);
      const R = (num >> 16) - amt;
      const G = (num >> 8 & 0x00FF) - amt;
      const B = (num & 0x0000FF) - amt;
      
      return "#" + (
        0x1000000 +
        (R < 0 ? 0 : R) * 0x10000 +
        (G < 0 ? 0 : G) * 0x100 +
        (B < 0 ? 0 : B)
      ).toString(16).slice(1);
    }

    // ====== Function to load logo in preview ======
    function loadPreviewLogo(url, alt) {
      const logoContainer = document.getElementById('previewLogoContainer');
      logoContainer.innerHTML = ''; // Clear container
      
      const img = document.createElement('img');
      img.src = url;
      img.alt = alt;
      img.onerror = function() {
        console.error("Error loading logo:", this.src);
        // Try to load a fallback logo if main one fails
        img.src = 'https://via.placeholder.com/600x120/003cff/ffffff?text=Logo+Placeholder';
      };
      
      logoContainer.appendChild(img);
    }

    // ====== Function to create header in preview ======
    function createPreviewHeader(containerId, titleConfig, descriptionConfig, thanksConfig) {
      const container = document.getElementById(containerId);
      container.innerHTML = ''; // Clear container
      
      // Create main container
      const formContainer = document.createElement("div");
      formContainer.className = "preview-form-container3";
      
      // Create title section
      if (titleConfig.title) {
        const titleSection = document.createElement("div");
        titleSection.className = "header-section";
        
        const titleElement = document.createElement("div");
        titleElement.className = "preview-title";
        titleElement.textContent = titleConfig.title;
        titleSection.appendChild(titleElement);
        
        formContainer.appendChild(titleSection);
      }
      
      // Create description section
      if (descriptionConfig.descriptionHTML) {
        const descriptionSection = document.createElement("div");
        descriptionSection.className = "header-section";
        
        const descriptionElement = document.createElement("div");
        descriptionElement.className = "preview-description-container";
        descriptionElement.innerHTML = descriptionConfig.descriptionHTML;
        descriptionSection.appendChild(descriptionElement);
        
        formContainer.appendChild(descriptionSection);
      }
      
      // Create thanks section (initially hidden)
      if (thanksConfig.thanksHTML) {
        const thanksSection = document.createElement("div");
        thanksSection.className = "header-section";
        thanksSection.id = "previewThanksSection";
        thanksSection.style.display = "none";
        
        const thanksElement = document.createElement("div");
        thanksElement.className = "preview-thanks-container";
        thanksElement.innerHTML = thanksConfig.thanksHTML;
        thanksSection.appendChild(thanksElement);
        
        formContainer.appendChild(thanksSection);
      }
      
      // Assemble
      container.appendChild(formContainer);
    }

    // ====== Function to create questions in preview ======
// ====== Function to create questions in preview ======
// ====== Function to create questions in preview ======
function createPreviewQuestion(containerId, config) {
  const container = document.getElementById(containerId);

  // ✅ Patch: asegurar que las opciones existan
  if (config.type === "radio" || config.type === "checkbox" || config.type === "dropdown") {
    if (!config.options || !Array.isArray(config.options) || config.options.length === 0) {
      console.warn(`⚠️ ${config.name} llegó sin opciones, intentando recuperar...`);
      // Buscar en la config global original
      if (window.questionsConfig && Array.isArray(window.questionsConfig)) {
        const original = window.questionsConfig.find(q => q.name === config.name);
        if (original && original.options && original.options.length > 0) {
          config.options = original.options;
          console.info(`✅ Opciones restauradas para ${config.name}`, config.options);
        }
      }
    }
  }

  // Create main container
  const formContainer = document.createElement("div");
  formContainer.className = "preview-form-container2";
  formContainer.style.display = config.hidden ? "none" : "block";
  formContainer.id = `preview-container-${config.name}`;
  formContainer.dataset.required = config.required || false;

  // Create question block
  const questionContainer = document.createElement("div");
  questionContainer.className = "preview-question-container";

  if (config.text) {
    const questionText = document.createElement("div");
    if (config.type === "textblock") {
      questionText.className = "preview-textblock";
      questionText.innerHTML = config.text;
    } else {
      questionText.className = "preview-question";
      if (config.required) {
        questionText.innerHTML = config.text + ' <span class="preview-required-marker">*</span>';
      } else {
        questionText.innerHTML = config.text;
      }
    }
    questionContainer.appendChild(questionText);
  }

  let inputGroup;

  // Different field types
  if (config.type === "date") {
    inputGroup = document.createElement("input");
    inputGroup.type = "date";
    inputGroup.className = "preview-input";
    inputGroup.name = config.name;
    inputGroup.id = config.name;
    if (config.required) inputGroup.required = true;

  } else if (config.type === "time") {
    inputGroup = document.createElement("input");
    inputGroup.type = "time";
    inputGroup.className = "preview-input";
    inputGroup.name = config.name;
    inputGroup.id = config.name;
    if (config.required) inputGroup.required = true;

  } else if (config.type === "text") {
    inputGroup = document.createElement("input");
    inputGroup.type = "text";
    inputGroup.className = "preview-input";
    inputGroup.name = config.name;
    inputGroup.id = config.name;
    inputGroup.placeholder = config.placeholder || "";
    if (config.required) inputGroup.required = true;

  } else if (config.type === "paragraph") {
    inputGroup = document.createElement("textarea");
    inputGroup.className = "preview-textarea";
    inputGroup.name = config.name;
    inputGroup.id = config.name;
    inputGroup.placeholder = config.placeholder || "";
    if (config.required) inputGroup.required = true;

  } else if (config.type === "dropdown") {
    inputGroup = document.createElement("div");

    const select = document.createElement("select");
    select.className = "preview-select";
    select.name = config.name;
    select.id = config.name;
    if (config.required) select.required = true;

    const defaultOption = document.createElement("option");
    defaultOption.value = "";
    defaultOption.textContent = config.placeholder || "Select an option";
    defaultOption.disabled = true;
    defaultOption.selected = true;
    select.appendChild(defaultOption);

    if (config.options && config.options.length > 0) {
      config.options.forEach(opt => {
        const option = document.createElement("option");
        option.value = opt.value;
        option.textContent = opt.label;
        select.appendChild(option);
      });
    }

    const otherInput = document.createElement("input");
    otherInput.type = "text";
    otherInput.className = "preview-input";
    otherInput.placeholder = "Please specify";
    otherInput.style.display = "none";
    otherInput.id = `preview_${config.name}_other`;

    select.addEventListener("change", () => {
      if (select.value === "other") {
        otherInput.style.display = "block";
        otherInput.required = config.required;
      } else {
        otherInput.style.display = "none";
        otherInput.value = "";
        otherInput.required = false;
      }
    });

    inputGroup.appendChild(select);
    inputGroup.appendChild(otherInput);

  } else if (config.type === "signature") {
    inputGroup = document.createElement("div");

    const info = document.createElement("p");
    info.className = "preview-signature-info";
    info.innerHTML = config.infoHTML || "";

    const canvas = document.createElement("canvas");
    canvas.className = "preview-canvas";
    canvas.id = "preview_" + config.name + "_canvas";

    const clearButton = document.createElement("button");
    clearButton.type = "button";
    clearButton.textContent = "Erase";
    clearButton.className = "preview-button";
    clearButton.style.marginTop = "8px";

    inputGroup.appendChild(info);
    inputGroup.appendChild(canvas);
    inputGroup.appendChild(document.createElement("br"));
    inputGroup.appendChild(clearButton);

    setTimeout(() => initPreviewSignaturePad(canvas, clearButton), 0);

  } else if (config.type === "textblock") {
    inputGroup = document.createElement("div");
    inputGroup.className = "preview-textblock-content";
    if (config.contentHTML) {
      inputGroup.innerHTML = config.contentHTML;
    }

  } else if (config.type === "radio" || config.type === "checkbox") {
    inputGroup = document.createElement("div");
    inputGroup.className = config.type === "checkbox" ? "preview-checkbox-group" : "preview-radio-group";

    if (config.options && config.options.length > 0) {
      config.options.forEach((opt, i) => {
        const label = document.createElement("label");
        const input = document.createElement("input");

        input.type = config.type;
        input.className = "preview-input";
        input.id = `preview_${config.name}_${i}`;
        input.name = config.name;
        input.value = opt.value;
        if (config.required) input.required = config.required;

        label.appendChild(input);
        label.append(` ${opt.label}`);

        if (opt.value === "other") {
          const otherInput = document.createElement("input");
          otherInput.type = "text";
          otherInput.className = "preview-input";
          otherInput.placeholder = "Please specify";
          otherInput.style.display = "none";
          otherInput.id = `preview_${config.name}_other`;

          input.addEventListener("change", () => {
            if (config.type === "radio") {
              otherInput.style.display = input.checked ? "block" : "none";
              otherInput.required = input.checked && config.required;
            } else {
              otherInput.style.display = input.checked ? "block" : "none";
              otherInput.required = input.checked && config.required;
            }
            if (!input.checked) otherInput.value = "";
          });

          label.appendChild(document.createElement("br"));
          label.appendChild(otherInput);
        }

        inputGroup.appendChild(label);
        inputGroup.appendChild(document.createElement("br"));
      });
    }
  }

  if (config.type !== "textblock") {
    const warning = document.createElement("div");
    warning.className = "preview-warning";
    warning.id = `preview_warning_${config.name}`;
    warning.textContent = "This is a required field";
    warning.style.display = "none";
    questionContainer.appendChild(warning);
  }

  if (inputGroup) {
    questionContainer.appendChild(inputGroup);
  }
  formContainer.appendChild(questionContainer);
  container.appendChild(formContainer);
}

    // ====== Function to initialize signature canvas in preview ======
    function initPreviewSignaturePad(canvas, clearButton) {
      const ctx = canvas.getContext("2d");
      let drawing = false;
      let pos = { x: 0, y: 0 };
      
      // Adjust canvas size
      function resizeCanvas() {
        const width = canvas.offsetWidth;
        const height = width * 0.6;
        canvas.width = width;
        canvas.height = height;
        
        // Styles for drawing
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.strokeStyle = '#000';
      }
      
      // Set initial position
      function setPosition(e) {
        const rect = canvas.getBoundingClientRect();
        if (e.touches) {
          pos.x = e.touches[0].clientX - rect.left;
          pos.y = e.touches[0].clientY - rect.top;
        } else {
          pos.x = e.clientX - rect.left;
          pos.y = e.clientY - rect.top;
        }
      }
      
      // Function to draw
      function draw(e) {
        if (!drawing) return;
        
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);
        setPosition(e);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
      }
      
      // Mouse events
      canvas.addEventListener('mousedown', (e) => {
        drawing = true;
        setPosition(e);
      });
      
      canvas.addEventListener('mouseenter', (e) => {
        if (e.buttons === 1) {
          drawing = true;
          setPosition(e);
        }
      });
      
      canvas.addEventListener('mouseup', () => {
        drawing = false;
      });
      
      canvas.addEventListener('mousemove', draw);
      
      // Touch events
      canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        drawing = true;
        setPosition(e);
      }, { passive: false });
      
      canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (!drawing) return;
        draw(e);
      }, { passive: false });
      
      canvas.addEventListener('touchend', () => {
        drawing = false;
      }, { passive: false });
      
      // Button to erase
      clearButton.addEventListener('click', () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      });
      
      // Initialize size
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
    }

    // ====== Function to submit from preview ======
// ====== Function to submit from preview ======
// ====== Function to submit from preview ======
async function previewSend() {
  const submitBtn = document.getElementById("previewSubmit");
  const overlay = document.getElementById("previewLoadingOverlay");
  const errorDiv = document.getElementById('previewErrorMessage');

  // Hide previous error messages
  errorDiv.style.display = 'none';
  submitBtn.disabled = true;

  let hasError = false;
  let firstErrorElement = null;
  const payload = {};

  // Iterate through all form-container2
  document.querySelectorAll(".preview-form-container2").forEach(container => {
    const input = container.querySelector("input, textarea, select, canvas");
    if (!input) return;

    const name = input.name || container.id;
    const warning = container.querySelector(".preview-warning");
    const isRequired = container.dataset.required === "true";

    // If it's a textblock, don't process as input field
    if (container.querySelector(".preview-textblock")) {
      return;
    }

    let value;
    let isEmpty = false;

    if (input.tagName === "CANVAS") {
      // Signature handling
      const ctx = input.getContext("2d");
      const imageData = ctx.getImageData(0, 0, input.width, input.height).data;
      isEmpty = true;
      
      for (let i = 0; i < imageData.length; i += 4) {
        if (imageData[i + 3] !== 0) {
          isEmpty = false;
          break;
        }
      }

      if (!isEmpty) {
        value = {
          filename: `signature_${Date.now()}.png`,
          mimeType: "image/png",
          data: input.toDataURL("image/png").split(",")[1]
        };
      }
    } else if (input.type === "radio") {
      // ✅ RADIO BUTTONS
      const checked = container.querySelector("input[type='radio']:checked");
      isEmpty = !checked;

      if (!isEmpty) {
        if (checked.value === "other") {
          const otherInput = container.querySelector(`#preview_${name}_other`);
          if (!otherInput || !otherInput.value.trim()) {
            isEmpty = true; // 🔴 obligatorio si se selecciona Other
          } else {
            value = otherInput.value.trim();
          }
        } else {
          value = checked.value;
        }
      } else {
        value = "";
      }

    } else if (input.type === "checkbox") {
      // ✅ CHECKBOXES
      const checked = container.querySelectorAll("input[type='checkbox']:checked");
      isEmpty = checked.length === 0;

      if (!isEmpty) {
        value = [...checked].map(el => {
          if (el.value === "other") {
            const otherInput = container.querySelector(`#preview_${name}_other`);
            if (!otherInput || !otherInput.value.trim()) {
              isEmpty = true; // 🔴 obligatorio si se selecciona Other
              return null;
            }
            return otherInput.value.trim();
          }
          return el.value;
        }).filter(v => v !== null);

        value = Array.isArray(value) ? value : [value];
      } else {
        value = [];
      }

    } else if (input.tagName === "SELECT") {
      // ✅ DROPDOWNS
      isEmpty = input.value === "";
      value = input.value;

      if (input.value === "other") {
        const otherInput = container.querySelector(`#preview_${name}_other`);
        if (!otherInput || !otherInput.value.trim()) {
          isEmpty = true; // 🔴 obligatorio si se selecciona Other
        } else {
          value = otherInput.value.trim();
        }
      }

    } else {
      // Text, textarea, date or time
      value = input.value.trim();
      isEmpty = !value;
    }

    // Show warning only if field is required and empty
    if (isRequired && isEmpty && warning) {
      warning.style.display = "block";
      hasError = true;
      if (!firstErrorElement) firstErrorElement = container;
    } else if (warning) {
      warning.style.display = "none";
    }

    // ✅ Always assign value to payload
    payload[name] = value;
  });

  if (hasError) {
    if (firstErrorElement) {
      firstErrorElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
    submitBtn.disabled = false;
    return;
  }

  showLoading();

  try {
    console.log("Payload a enviar:", JSON.stringify(payload, null, 2));
    
    const response = await fetch(SUBMIT_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'text/plain;charset=utf-8',
      },
      body: JSON.stringify(payload)
    });

    const result = await response.json();
    console.log("Respuesta del servidor:", result);

    if (result.success) {
      document.getElementById("previewFormRoot").style.display = "none";
      document.getElementById("previewSubmit").style.display = "none";
      document.getElementById("previewThanksSection").style.display = "block";
    } else {
      showPreviewError("Error sending data: " + result.error);
    }
    
  } catch (err) {
    console.error("Error sending data:", err);
    showPreviewError("Connection error. Please try again.");
  } finally {
    submitBtn.disabled = false;
    hideLoading();
  }
}



    document.addEventListener('click', (e) => {
  if (!e.target.classList.contains('format-btn')) return;
  const command = e.target.dataset.command;
  const editor = e.target.closest('.question-header, .form-header, .closing-message')
                        .querySelector('[contenteditable]');
  if (editor) {
    document.execCommand(command, false, null);
    editor.focus();
  }
});


    // ====== Function to show errors in preview ======
    function showPreviewError(message) {
      const errorDiv = document.getElementById('previewErrorMessage');
      errorDiv.textContent = message;
      errorDiv.style.display = 'block';
      
      // Scroll to top to show error
      window.scrollTo({ top: 0, behavior: 'smooth' });
      
      // Hide error after 5 seconds
      setTimeout(() => {
        errorDiv.style.display = 'none';
      }, 5000);
    }

    // ====== Initialize improved drag system ======
    function initImprovedDragSystem() {
      const questionsDiv = document.getElementById("questions");
      let dragElement = null;
      let isDragging = false;
      let startX, startY;
      
      // Add drag handlers to all blocks
      function addDragHandlers() {
        document.querySelectorAll('.question-block, .text-block, .image-block, .section-block').forEach(block => {
          const dragHandle = block.querySelector('.drag-handle') || createDragHandle(block);
          
          // Configure events for drag handle
          dragHandle.addEventListener('mousedown', startDrag);
          dragHandle.addEventListener('touchstart', startDrag, { passive: false });
          
          // Prevent drag start on editable elements
          block.querySelectorAll('[contenteditable="true"], input, textarea, select').forEach(element => {
            element.addEventListener('mousedown', (e) => {
              e.stopPropagation();
            });
            
            element.addEventListener('touchstart', (e) => {
              e.stopPropagation();
            }, { passive: true });
          });
        });
      }
      
      // Create a drag handle if it doesn't exist
      function createDragHandle(block) {
        const dragHandle = document.createElement('div');
        dragHandle.className = 'drag-handle';
        dragHandle.innerHTML = '≡';
        dragHandle.title = 'Drag block';
        block.insertBefore(dragHandle, block.firstChild);
        return dragHandle;
      }
      
      // Start drag
      function startDrag(e) {
        // Only start drag with left mouse button
        if (e.type === 'mousedown' && e.button !== 0) return;
        
        dragElement = this.closest('.question-block, .text-block, .image-block, .section-block');
        if (!dragElement) return;
        
        isDragging = false;
        startX = e.type === 'mousedown' ? e.clientX : e.touches[0].clientX;
        startY = e.type === 'mousedown' ? e.clientY : e.touches[0].clientY;
        
        // Add movement and end events
        document.addEventListener('mousemove', onDrag);
        document.addEventListener('touchmove', onDrag, { passive: false });
        document.addEventListener('mouseup', stopDrag);
        document.addEventListener('touchend', stopDrag);
        
        e.preventDefault();
        if (e.type === 'touchstart') e.preventDefault();
      }
      
      // During drag
      function onDrag(e) {
        if (!dragElement) return;
        
        const currentX = e.type === 'mousemove' ? e.clientX : e.touches[0].clientX;
        const currentY = e.type === 'mousemove' ? e.clientY : e.touches[0].clientY;
        
        // Check if movement is sufficient to be considered drag
        if (!isDragging) {
          const dx = Math.abs(currentX - startX);
          const dy = Math.abs(currentY - startY);
          
          // Only start drag if movement is greater than threshold
          if (dx > 5 || dy > 5) {
            isDragging = true;
            dragElement.classList.add('dragging');
            
            // Create ghost element for drag
            const rect = dragElement.getBoundingClientRect();
            const ghost = dragElement.cloneNode(true);
            ghost.style.position = 'fixed';
            ghost.style.width = `${rect.width}px`;
            ghost.style.height = `${rect.height}px`;
            ghost.style.left = `${rect.left}px`;
            ghost.style.top = `${rect.top}px`;
            ghost.style.zIndex = '1000';
            ghost.style.opacity = '0.8';
            ghost.style.pointerEvents = 'none';
            ghost.id = 'ghost-element';
            document.body.appendChild(ghost);
          }
        }
        
        if (isDragging) {
          e.preventDefault();
          
          // Move ghost element
          const ghost = document.getElementById('ghost-element');
          if (ghost) {
            ghost.style.left = `${currentX - 50}px`;
            ghost.style.top = `${currentY - 20}px`;
          }
          
          // Find element after which to insert
          const afterElement = getDragAfterElement(questionsDiv, currentY);
          if (afterElement == null) {
            questionsDiv.appendChild(dragElement);
          } else {
            questionsDiv.insertBefore(dragElement, afterElement);
          }
        }
      }
      
      // Stop drag
      function stopDrag() {
        if (dragElement && isDragging) {
          dragElement.classList.remove('dragging');
        }
        
        // Remove ghost element
        const ghost = document.getElementById('ghost-element');
        if (ghost) {
          document.body.removeChild(ghost);
        }
        
        // Clean variables and events
        dragElement = null;
        isDragging = false;
        
        document.removeEventListener('mousemove', onDrag);
        document.removeEventListener('touchmove', onDrag);
        document.removeEventListener('mouseup', stopDrag);
        document.removeEventListener('touchend', stopDrag);
      }
      
      // Find element after which to insert
      function getDragAfterElement(container, y) {
        const draggableElements = [...container.querySelectorAll(".question-block:not(.dragging), .section-block:not(.dragging), .text-block:not(.dragging), .image-block:not(.dragging)")];
        
        return draggableElements.reduce((closest, child) => {
          const box = child.getBoundingClientRect();
          const offset = y - box.top - box.height / 2;
          if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
          } else {
            return closest;
          }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
      }
      
      // Initialize drag handlers
      addDragHandlers();
      
      // Observe DOM changes to add handlers to new elements
      const observer = new MutationObserver(addDragHandlers);
      observer.observe(questionsDiv, { childList: true, subtree: true });
    }

    // ====== Initialize rich text editors ======
    function initRichTextEditors() {
      // Configure placeholders for content editable editors
      document.querySelectorAll('[contenteditable][data-placeholder]').forEach(editor => {
        const placeholder = editor.getAttribute('data-placeholder');
        
        // Set initial placeholder if empty
        if (!editor.textContent.trim()) {
          editor.innerHTML = '';
          editor.classList.add('placeholder');
        }
        
        // Handle focus
        editor.addEventListener('focus', function() {
          if (this.classList.contains('placeholder')) {
            this.innerHTML = '';
            this.classList.remove('placeholder');
          }
        });
        
        editor.addEventListener('blur', function() {
          if (!this.textContent.trim()) {
            this.innerHTML = '';
            this.classList.add('placeholder');
          }
        });
      });
      
      // Configure format buttons
      document.querySelectorAll('.format-btn').forEach(button => {
        button.addEventListener('click', function() {
          const command = this.dataset.command;
          const editor = this.closest('.question-header, .form-header, .closing-message')
            .querySelector('[contenteditable]');
          
          if (editor) {
            document.execCommand(command, false, null);
            editor.focus();
          }
        });
      });
    }

    // ====== Function to load configuration ======
    async function loadConfig() {
      try {
        const response = await fetch(CONFIG_URL);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        
        const result = await response.json();
        console.log("Server response:", result);
        
        if (!result.success) {
          throw new Error(result.message);
        }
        
        const configData = JSON.parse(result.config);
        return configData;
        
      } catch (error) {
        console.error("Error loading config from URL:", error);
        console.log("Using default configuration...");
        
        try {
          return JSON.parse(DEFAULT_CONFIG_STRING);
        } catch (parseError) {
          console.error("Error parsing default config:", parseError);
          showError("Error loading form configuration. Please try again later.");
          return null;
        }
      }
    }

    // ====== Logo initialization ======
    function initLogo() {
      const logoUrlInput = document.getElementById('logoUrl');
      const logoPreview = document.getElementById('logoPreview');
      
      // Update logo preview
      function updateLogoPreview() {
        const url = logoUrlInput.value.trim();
        if (url) {
          logoPreview.innerHTML = `<img src="${url}" alt="Logo" onerror="this.style.display='none'; logoPreview.innerHTML='<span style=color:#999;font-size:12px;>Invalid image</span>';" />`;
        } else {
          logoPreview.innerHTML = '<span style="color: #999; font-size: 12px;">Logo preview</span>';
        }
      }
      
      // Event to update preview when URL changes
      logoUrlInput.addEventListener('input', updateLogoPreview);
      
      // Initialize preview
      updateLogoPreview();
    }

    // ====== Show toast/notification ======
    function showToast(message, isError = false) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.style.backgroundColor = isError ? '#d93025' : '#333';
      toast.classList.add('show');
      
      setTimeout(() => {
        toast.classList.remove('show');
      }, 3000);
    }

    // ====== Block creators ======
    function createQuestionBlock(type = "text") {
      const count = fieldCounters[type]++;
      const fieldName = `${type}_${count}`;
      
      const block = document.createElement("div");
      block.className = "question-block";
      block.dataset.type = type;
      block.dataset.name = fieldName;
      
      block.innerHTML = `
        <div class="drag-handle" title="Drag block">≡</div>
        <div class="question-header">
          <div class="format-toolbar">
            <button class="format-btn" data-command="bold" title="Bold">B</button>
          </div>
          <div class="rich-text-editor question-input" contenteditable="true" data-placeholder="Enter the question here"></div>
          <select class="type-select">
            <option value="radio">Multiple choice</option>
            <option value="checkbox">Checkboxes</option>
            <option value="dropdown">Dropdown</option>
            <option value="text" ${type === "text" ? "selected" : ""}>Short answer</option>
            <option value="paragraph" ${type === "paragraph" ? "selected" : ""}>Paragraph</option>
            
            <option value="date" ${type === "date" ? "selected" : ""}>Date</option>
            <option value="time" ${type === "time" ? "selected" : ""}>Time</option>
          
            <option value="signature" ${type === "signature" ? "selected" : ""}>Signature</option>
          </select>
        </div>
        
        <div class="question-body">
          <input type="text" class="short-answer-input" placeholder="Enter your answer here">
          <div class="name-display">Field name: ${fieldName}</div>
        </div>
        
        <div class="question-footer">
          <label class="required-toggle">
            <input type="checkbox" class="required-checkbox" /> Required
          </label>
          
          <div class="action-buttons">
            <button class="action-btn" title="Duplicate question" onclick="duplicateQuestion(this)">⎘</button>
            
            <button class="delete-btn" title="Delete block">🗑️</button>
          </div>
        </div>
      `;
      
      // Set correct type
      setTimeout(() => {
        const select = block.querySelector(".type-select");
        select.value = type;
        const event = new Event('change', { bubbles: true });
        select.dispatchEvent(event);
        
        // Initialize rich text editor
        initRichTextEditors();
      }, 0);
      
      return block;
    }

    function createTextBlock() {
      const count = fieldCounters['textblock']++;
      const fieldName = `textblock_${count}`;
      
      const block = document.createElement("div");
      block.className = "text-block";
      block.dataset.type = "textblock";
      block.dataset.name = fieldName;
      
      block.innerHTML = `
        <div class="drag-handle" title="Drag block">≡</div>
        <div class="question-header">
          <div class="format-toolbar">
            <button class="format-btn" data-command="bold" title="Bold">B</button>
          </div>
          <div class="rich-text-editor" contenteditable="true" data-placeholder="Write text here"></div>
          <button class="delete-btn" aria-label="Delete block">🗑️</button>
        </div>
        <div class="name-display">Field name: ${fieldName}</div>
      `;
      
      // Initialize rich text editor
      setTimeout(() => {
        initRichTextEditors();
      }, 0);
      
      return block;
    }

    function createImageBlock() {
      const block = document.createElement("div");
      block.className = "image-block";
      block.innerHTML = `
        <div class="drag-handle" title="Drag block">≡</div>
        <div class="question-header">
          <input type="file" accept="image/*" class="image-upload" />
          <button class="delete-btn" aria-label="Delete block">🗑️</button>
        </div>
        <div class="image-preview"></div>
      `;
      const input = block.querySelector(".image-upload");
      const preview = block.querySelector(".image-preview");
      input.addEventListener("change", () => {
        const file = input.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            preview.innerHTML = `<img src="${e.target.result}" style="max-width:100%; border-radius:8px;" />`;
          };
          reader.readAsDataURL(file);
        }
      });
      return block;
    }

    function createSectionBlock() {
      const block = document.createElement("div");
      block.className = "section-block";
      block.innerHTML = `
        <div class="drag-handle" title="Drag block">≡</div>
        <input class="section-title" type="text" value="New section" />
        <div class="format-toolbar">
          <button class="format-btn" data-command="bold" title="Bold">B</button>
        </div>
        <div class="rich-text-editor" contenteditable="true" data-placeholder="Section description"></div>
        <button class="delete-btn" aria-label="Delete section">🗑️</button>
      `;
      
      // Initialize rich text editor
      setTimeout(() => {
        initRichTextEditors();
      }, 0);
      
      return block;
    }

    // ====== Sidebar: add blocks ======
    document.getElementById("addQuestion").addEventListener("click", () => {
      document.getElementById("questions").appendChild(createQuestionBlock());
    });
    document.getElementById("addText").addEventListener("click", () => {
      document.getElementById("questions").appendChild(createTextBlock());
    });
    document.getElementById("addImage").addEventListener("click", () => {
      document.getElementById("questions").appendChild(createImageBlock());
    });
    document.getElementById("addSection").addEventListener("click", () => {
      document.getElementById("questions").appendChild(createSectionBlock());
    });

    // ====== Change question type (delegate) ======
    document.getElementById("questions").addEventListener("change", (e) => {
      if (!e.target.classList.contains("type-select")) return;

      const block = e.target.closest(".question-block");
      const questionBody = block.querySelector(".question-body");
      const addOptionLink = block.querySelector(".add-option");
      const type = e.target.value;
      
      // Update type and name in dataset
      const oldType = block.dataset.type;
      const oldName = block.dataset.name;
      
      // Extract number from old name
      const numberMatch = oldName.match(/\d+$/);
      const fieldNumber = numberMatch ? numberMatch[0] : fieldCounters[type]++;
      
      // Generate new name
      const newName = `${type}_${fieldNumber}`;
      block.dataset.type = type;
      block.dataset.name = newName;
      
      // Update name display (even if hidden)
      const nameDisplay = block.querySelector(".name-display");
      if (nameDisplay) {
        nameDisplay.textContent = `Field name: ${newName}`;
      }

      if (!questionBody) return;
      
      // Save current placeholder if exists
      const currentInput = block.querySelector(".short-answer-input, .paragraph-input");
      const currentPlaceholder = currentInput ? currentInput.placeholder : "";
      
      // Clean question body but keep input and name display
      const inputElement = block.querySelector(".short-answer-input, .paragraph-input");
      const nameDisplayElement = block.querySelector(".name-display");
      
      questionBody.innerHTML = '';
      
      // Reinsert elements
      if (inputElement) {
        questionBody.appendChild(inputElement);
      }
      if (nameDisplayElement) {
        questionBody.appendChild(nameDisplayElement);
      }
      if (["radio", "checkbox","dropdown"].includes(type)) {
  const addOtherLink = document.createElement("div");
  addOtherLink.textContent = "Add 'Other'";
  addOtherLink.className = "add-other";


  questionBody.appendChild(addOtherLink);
}


      // Show or hide placeholder field based on type
      if (["text", "paragraph"].includes(type)) {
        inputElement.style.display = "block";
        
        // Change input type based on field type
        if (type === "paragraph") {
          inputElement.className = "paragraph-input";
          inputElement.placeholder = "Enter your answer here";
          inputElement.rows = 4;
        } else {
          inputElement.className = "short-answer-input";
          inputElement.placeholder = "Enter your answer here";
          inputElement.removeAttribute("rows");
        }
      } else {
        inputElement.style.display = "none";
      }

      const showAdd = (show) => {
        if (addOptionLink) addOptionLink.style.display = show ? "block" : "none";
      };

      if (type === "text") {
        questionBody.innerHTML += `
          <div class="short-answer-text">Short answer</div>
        `;
        showAdd(false);
      } else if (type === "file") {
        questionBody.innerHTML += `<input type="file" style="margin:8px 0;" />`;
        showAdd(false);
      } else if (type === "date") {
        questionBody.innerHTML += `<input type="date" style="margin:8px 0; padding:4px; border:1px solid #ccc; border-radius:4px;" />`;
        showAdd(false);
      } else if (type === "time") {
        questionBody.innerHTML += `<input type="time" style="margin:8px 0; padding:4px; border:1px solid #ccc; border-radius:4px;" />`;
        showAdd(false);
      } else if (type === "signature") {
        questionBody.innerHTML += `
          <div style="margin:10px 0;">
            <canvas class="signature-canvas" width="400" height="150" style="border:1px solid #ccc; border-radius:4px; background:#fff; cursor:crosshair;"></canvas><br />
            <button type="button" class="erase-signature" style="margin-top:6px; padding:4px 10px; border:1px solid #ccc; border-radius:4px; cursor:pointer;">Erase</button>
          </div>
        `;
        showAdd(false);

        const canvas = block.querySelector(".signature-canvas");
        const eraseBtn = block.querySelector(".erase-signature");
        const ctx = canvas.getContext("2d");
        let drawing = false;

        const getX = (ev) => ev.offsetX ?? (ev.touches[0].clientX - canvas.getBoundingClientRect().left);
        const getY = (ev) => ev.offsetY ?? (ev.touches[0].clientY - canvas.getBoundingClientRect().top);

        function startDraw(ev) { drawing = true; ctx.beginPath(); ctx.moveTo(getX(ev), getY(ev)); }
        function draw(ev) { if (!drawing) return; ctx.lineWidth = 2; ctx.lineCap = "round"; ctx.strokeStyle = "#000"; ctx.lineTo(getX(ev), getY(ev)); ctx.stroke(); }
        function stopDraw() { drawing = false; ctx.closePath(); }

        // Mouse
        canvas.addEventListener("mousedown", startDraw);
        canvas.addEventListener("mousemove", draw);
        canvas.addEventListener("mouseup", stopDraw);
        canvas.addEventListener("mouseout", stopDraw);
        // Touch
        canvas.addEventListener("touchstart", (ev) => { ev.preventDefault(); startDraw(ev); }, { passive: false });
        canvas.addEventListener("touchmove", (ev) => { ev.preventDefault(); draw(ev); }, { passive: false });
        canvas.addEventListener("touchend", stopDraw);

        eraseBtn.addEventListener("click", () => { ctx.clearRect(0, 0, canvas.width, canvas.height); });
      } else if (type === "slider") {
        questionBody.innerHTML += `
          <label style="font-size:14px; color:#5f6368;">Min: <input type="number" class="slider-min" value="0" style="width:60px; margin-right:10px;"> Max: <input type="number" class="slider-max" value="100" style="width:60px; margin-right:10px;"></label>
          <br>
          <label style="font-size:13px; margin-left:10px;"><input type="checkbox" class="slider-show-value" checked> Show value</label>
          <br>
          <input type="range" min="0" max="100" value="50" class="slider-preview" style="width:80%; margin-top:10px;">
          <br>
          <span class="slider-value" style="margin-left:8px; font-weight:bold; color:#202124;">50</span>
        `;
        showAdd(false);

        const minInput = block.querySelector(".slider-min");
        const maxInput = block.querySelector(".slider-max");
        const slider = block.querySelector(".slider-preview");
        const valueSpan = block.querySelector(".slider-value");
        const showValueCheckbox = block.querySelector(".slider-show-value");

        function normalize() {
          let min = Number(minInput.value || 0);
          let max = Number(maxInput.value || 100);
          if (max < min) [min, max] = [max, min];
          minInput.value = String(min);
          maxInput.value = String(max);
          slider.min = min;
          slider.max = max;
          if (Number(slider.value) < min) slider.value = String(min);
          if (Number(slider.value) > max) slider.value = String(max);
          valueSpan.textContent = slider.value;
        }
        slider.addEventListener("input", () => { valueSpan.textContent = slider.value; });
        showValueCheckbox.addEventListener("change", () => { valueSpan.style.display = showValueCheckbox.checked ? "inline" : "none"; });
        minInput.addEventListener("input", normalize);
        maxInput.addEventListener("input", normalize);
        normalize();
      } else if (type === "paragraph") {
        questionBody.innerHTML += `
          <div class="short-answer-text">Long answer</div>
        `;
        showAdd(false);
      } else if (type === "dropdown") {
        questionBody.innerHTML += `
          <div class="options">
            <div class="option">
              <span>1.</span>
              <input type="text" class="option-text" value="Option 1" placeholder="Option value" />
              <span class="delete-btn" title="Remove option">✖</span>
            </div>
            <div class="option">
              <span>2.</span>
              <input type="text" class="option-text" value="Option 2" placeholder="Option value" />
              <span class="delete-btn" title="Remove option">✖</span>
            </div>
          </div>
          <div class="add-option">+ Add option</div>
        `;
        showAdd(true);
      } else {
        // radio / checkbox - NOW WITH DELETE BUTTONS
        questionBody.innerHTML += `
          <div class="options">
            <div class="option">
              <input type="${type}" name="${newName}" />
              <input type="text" class="option-text" value="Option 1" placeholder="Option value" />
              <span class="delete-btn" title="Remove option">✖</span>
            </div>
            <div class="option">
              <input type="${type}" name="${newName}" />
              <input type="text" class="option-text" value="Option 2" placeholder="Option value" />
              <span class="delete-btn" title="Remove option">✖</span>
            </div>
          </div>
          <div class="add-option">+ Add option</div>
        `;
        showAdd(true);
      }
      
      // Restore placeholder value
      if (inputElement && currentPlaceholder) {
        inputElement.placeholder = currentPlaceholder;
      }
    });


// Evento delegado para "Add other" en el editor
// Evento delegado para "Add other" en el editor (REEMPLAZADO)
document.getElementById("questions").addEventListener("click", (e) => {
  if (!e.target.classList.contains("add-other")) return;
  e.preventDefault();

  const block = e.target.closest(".question-block");
  if (!block) return;
  const optionsContainer = block.querySelector(".options");
  if (!optionsContainer) return;

  const type = block.dataset.type || block.querySelector('.type-select')?.value;

  if (type === "dropdown") {
    // Dropdown: NO mostrar radio, mostrar número + texto + botón eliminar
    const optionCount = optionsContainer.querySelectorAll(".option").length + 1;
    const optionDiv = document.createElement("div");
    optionDiv.className = "option";
    optionDiv.innerHTML = `
      <span>${optionCount}.</span>
      <input type="text" class="option-text" value="Other" />
      <span class="delete-btn" title="Remove option">✖</span>
    `;
    optionsContainer.appendChild(optionDiv);
  } else {
    // Radio/Checkbox: mostrar input decorativo + texto editable + eliminar
    const qName = block.dataset.name || `${type}_${fieldCounters[type] ? fieldCounters[type]++ : 1}`;
    const optionDiv = document.createElement("div");
    optionDiv.className = "option";
    optionDiv.innerHTML = `
      <input type="${type === 'checkbox' ? 'checkbox' : 'radio'}" name="${qName}" disabled />
      <input type="text" class="option-text" value="Other" />
      <span class="delete-btn" title="Remove option">✖</span>
    `;
    optionsContainer.appendChild(optionDiv);
  }
});




    // ====== "+ Add option" and delete (delegate) ======
    document.getElementById("questions").addEventListener("click", (e) => {
      // Add option
      if (e.target.classList.contains("add-option")) {
        const block = e.target.closest(".question-block");
        const optionsDiv = block.querySelector(".options");
        const select = block.querySelector(".type-select");
        const type = select ? select.value : null;
        if (!optionsDiv || !type) return;

        // Types without options
        if (["text", "paragraph", "file", "date", "time", "signature", "slider"].includes(type)) return;

        if (type === "dropdown") {
          const optionCount = optionsDiv.querySelectorAll(".option").length + 1;
          const newOption = document.createElement("div");
          newOption.className = "option";
          newOption.innerHTML = `
            <span>${optionCount}.</span>
            <input type="text" class="option-text" value="New option" placeholder="Option value" />
            <span class="delete-btn" title="Remove option">✖</span>
          `;
          optionsDiv.appendChild(newOption);
        } else {
          const qName = block.dataset.name || `${type}_${fieldCounters[type]++}`;
          const newOption = document.createElement("div");
          newOption.className = "option";
          newOption.innerHTML = `
            <input type="${type}" name="${qName}" />
            <input type="text" class="option-text" value="New option" placeholder="Option value" />
            <span class="delete-btn" title="Remove option">✖</span>
          `;
          optionsDiv.appendChild(newOption);
        }
      }

      // Delete option or block/section
      if (e.target.classList.contains("delete-btn")) {
        const option = e.target.closest(".option");
        if (option) {
          const optionsDiv = e.target.closest(".options");
          option.remove();
          if (optionsDiv) {
            // Renumber options if dropdown
            const numbered = optionsDiv.querySelectorAll(".option > span:first-child");
            if (numbered.length) numbered.forEach((s, i) => (s.textContent = `${i + 1}.`));
          }
        } else {
          const block = e.target.closest(".question-block, .section-block, .text-block, .image-block");
          if (block) block.remove();
        }
      }
    });

    // ====== Functions for new buttons ======
    function duplicateQuestion(button) {
      const question = button.closest(".question-block");
      const type = question.dataset.type;
      const clonedQuestion = createQuestionBlock(type);
      
      // Copy question content
      const originalEditor = question.querySelector(".rich-text-editor.question-input");
      const clonedEditor = clonedQuestion.querySelector(".rich-text-editor.question-input");
      if (originalEditor && clonedEditor) {
        clonedEditor.innerHTML = originalEditor.innerHTML;
      }
      
      // Copy placeholder if exists
      const originalInput = question.querySelector(".short-answer-input, .paragraph-input");
      const clonedInput = clonedQuestion.querySelector(".short-answer-input, .paragraph-input");
      if (originalInput && clonedInput) {
        clonedInput.placeholder = originalInput.placeholder;
      }
      
      // Copy required state
      clonedQuestion.querySelector(".required-checkbox").checked = question.querySelector(".required-checkbox").checked;
      
      // Insert after current question
      question.parentNode.insertBefore(clonedQuestion, question.nextSibling);
    }

    function addImageToQuestion(button) {
      const question = button.closest(".question-block");
      const questionBody = question.querySelector(".question-body");
      
      // Create file input
      const fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = 'image/*';
      fileInput.style.display = 'none';
      
      // Add to DOM and simulate click
      document.body.appendChild(fileInput);
      fileInput.click();
      
      // Handle file selection
      fileInput.addEventListener('change', function() {
        if (this.files && this.files[0]) {
          const reader = new FileReader();
          
          reader.onload = function(e) {
            // Create image element
            const img = document.createElement('img');
            img.src = e.target.result;
            img.style.maxWidth = '100%';
            img.style.marginTop = '16px';
            img.style.borderRadius = '4px';
            
            // Insert image into question body
            questionBody.appendChild(img);
          }
          
          reader.readAsDataURL(this.files[0]);
        }
        
        // Clean up
        document.body.removeChild(fileInput);
      });
    }

// ====== Send to Google Apps Script ======
document.getElementById("sendToGoogle").addEventListener("click", async () => {
  const data = serializeForm();
  const toast = document.getElementById("toast");

  // 🔴 Add flag so backend knows it's configuration
  data._type = "config";

  try {
    toast.textContent = "Saving form...";
    toast.classList.add("show");
   

    const response = await fetch("https://script.google.com/macros/s/AKfycbzGabnF9fDLLuqNTnonsyOuAR_liKKyF_bEKR95FGb4cJd3hxAPjjcPgsutAjv6dbaC/exec", {
      method: 'POST',
      headers: { 'Content-Type': 'text/plain;charset=utf-8' },
      body: JSON.stringify(data)
    });

    const result = await response.json();

    // 🔵 Your backend returns { success: true }, not "status"
    if (result.success) {
      toast.textContent = result.message || "Configuration saved successfully";
    } else {
      throw new Error(result.message || "Error saving configuration");
    }

    setTimeout(() => toast.classList.remove("show"), 3000);
  } catch (error) {
    console.error("Error:", error);
    toast.textContent = error.message;
    setTimeout(() => toast.classList.remove("show"), 3000);
  }
});


  function serializeForm() {
  const formData = {
    logoConfig: {
      primaryColor: document.getElementById("themeColor").value,
      logo: {
        url: document.getElementById("logoUrl").value.trim(),
        alt: "Company Logo"
      }
    },
    titleConfig: {
      id: "header-title",
      title: document.querySelector(".form-title").value.trim()
    },
    descriptionConfig: {
      id: "header-description",
      descriptionHTML: document.getElementById("formDescription").innerHTML
    },
    thanksConfig: {
      id: "header-thanks",
      thanksHTML: document.getElementById("closingMessage").innerHTML
    },
    questionsConfig: []
  };

  document.querySelectorAll("#questions > .question-block, #questions > .text-block, #questions > .image-block, #questions > .section-block").forEach(block => {
    const type = block.dataset.type;
    const name = block.dataset.name;
    const required = block.querySelector(".required-checkbox")?.checked || false;

    if (type === "text" || type === "paragraph" || type === "date" || type === "time" || type === "signature") {
      formData.questionsConfig.push({
        type,
        name,
        text: block.querySelector(".question-input")?.innerHTML || "",
        placeholder: block.querySelector(".short-answer-input, .paragraph-input")?.placeholder || "",
        required
      });

    } else if (type === "radio" || type === "checkbox" || type === "dropdown") {
      const options = [];
      block.querySelectorAll(".option").forEach(opt => {
        if (opt.classList.contains("option-other")) {
          // opción especial Other
          options.push({ value: "other", label: "Other" });
        } else {
          const textEl = opt.querySelector(".option-text");
          if (textEl) {
            const text = textEl.value.trim();
            if (text) {
              options.push({
                value: text.toLowerCase().replace(/\s+/g, "_"),
                label: text
              });
            }
          }
        }
      });

      formData.questionsConfig.push({
        type,
        name,
        text: block.querySelector(".question-input")?.innerHTML || "",
        options,
        required
      });

    } else if (type === "textblock") {
      formData.questionsConfig.push({
        type,
        name,
        text: block.querySelector(".rich-text-editor")?.innerHTML || ""
      });

    } else if (type === "section") {
      formData.questionsConfig.push({
        type,
        name,
        title: block.querySelector(".section-title")?.value || "",
        description: block.querySelector(".rich-text-editor")?.innerHTML || ""
      });
    }
  });

  return formData;
}

    // Function to show validation information
    function showValidationInfo(data) {
      const validationStatus = document.getElementById('validationStatus');
      const requiredFields = data.questionsConfig.filter(q => q.required);
      
      if (requiredFields.length > 0) {
        
        validationStatus.className = 'validation-status status-ok';
      } else {
        
        validationStatus.className = 'validation-status status-error';
      }
    }

function loadForm(data) {
  // Theme
  if (data.logoConfig && data.logoConfig.primaryColor) {
    document.documentElement.style.setProperty('--main-color', data.logoConfig.primaryColor);
    document.getElementById('themeColor').value = data.logoConfig.primaryColor;
  }
  
  // Logo
  if (data.logoConfig && data.logoConfig.logo && data.logoConfig.logo.url) {
    document.getElementById('logoUrl').value = data.logoConfig.logo.url;
    // Update preview
    const logoPreview = document.getElementById('logoPreview');
    logoPreview.innerHTML = `<img src="${data.logoConfig.logo.url}" alt="Logo" onerror="this.style.display='none'; logoPreview.innerHTML='<span style=color:#999;font-size:12px;>Invalid image</span>';" />`;
  }
  
  // Header
  if (data.titleConfig) {
    document.querySelector(".form-title").value = data.titleConfig.title || "";
  }
  if (data.descriptionConfig) {
    document.getElementById('formDescription').innerHTML = data.descriptionConfig.descriptionHTML || "";
  }
  
  // Closing message
  if (data.thanksConfig && data.thanksConfig.thanksHTML) {
    document.getElementById('closingMessage').innerHTML = data.thanksConfig.thanksHTML;
  }

 // Content
  const container = document.getElementById("questions");
  container.innerHTML = "";
  
  // Reset counters
  for (const key in fieldCounters) {
    fieldCounters[key] = 1;
  }

  (data.questionsConfig || []).forEach((q) => {
    // Determine type for frontend
    let frontendType = q.type;
    if (q.type === "textarea") frontendType = "paragraph";
    
    let block;
    if (q.type === "textblock") {
      // ... código para textblock ...
    } else {
      // Create normal question block
      block = createQuestionBlock(frontendType);
      
      // Set basic values
      const editor = block.querySelector(".rich-text-editor.question-input");
      if (editor && q.text) {
        editor.innerHTML = q.text;
        editor.classList.remove('placeholder');
      }
      
      // Set if required
      if (q.required !== undefined) {
        const checkbox = block.querySelector(".required-checkbox");
        if (checkbox) {
          checkbox.checked = q.required;
        }
      }
      
      // Set placeholder if exists and is a text type
      if (q.placeholder && ["text", "paragraph"].includes(frontendType)) {
        const inputElement = block.querySelector(".short-answer-input, .paragraph-input");
        if (inputElement) {
          inputElement.placeholder = q.placeholder;
        }
      }
      
      // ✅ CORRECCIÓN: Manejar dropdown, radio y checkbox de manera más directa
      if (["radio", "checkbox", "dropdown"].includes(frontendType)) {
        const select = block.querySelector('.type-select');
        if (select) {
          select.value = frontendType;
          
          // ✅ EJECUTAR INMEDIATAMENTE sin setTimeout anidados
          const evt = new Event('change', { bubbles: true });
          select.dispatchEvent(evt);
          
          // ✅ ESPERAR UN FRAME para que el DOM se actualice, luego llenar opciones
          requestAnimationFrame(() => {
            if (q.options && q.options.length > 0) {
              const questionBody = block.querySelector(".question-body");
              const optionsDiv = questionBody.querySelector(".options");
              
              if (optionsDiv) {
                // Clear existing options (default ones)
                optionsDiv.innerHTML = "";
                
                // Add each option
                q.options.forEach((opt, idx) => {
                  const optionDiv = document.createElement("div");
                  optionDiv.className = "option";
                  
                  if (frontendType === "dropdown") {
                    optionDiv.innerHTML = `
                      <span>${idx + 1}.</span>
                      <input type="text" class="option-text" value="${opt.label.replace(/"/g, '&quot;')}" placeholder="Option value" />
                      <span class="delete-btn" title="Remove option">✖</span>
                    `;
                  } else {
                    optionDiv.innerHTML = `
                      <input type="${frontendType}" name="${q.name}" />
                      <input type="text" class="option-text" value="${opt.label.replace(/"/g, '&quot;')}" placeholder="Option value" />
                      <span class="delete-btn" title="Remove option">✖</span>
                    `;
                  }
                  
                  optionsDiv.appendChild(optionDiv);
                });
                
                // Add the "Add option" link if it doesn't exist
                if (!questionBody.querySelector('.add-option')) {
                  const addOptionLink = document.createElement("div");
                  addOptionLink.className = "add-option";
                  addOptionLink.textContent = "+ Add option";
                  questionBody.appendChild(addOptionLink);
                }
              }
            }
          });
        }
      } else {
        // For other types, just trigger the change event
        const evt = new Event('change', { bubbles: true });
        const select = block.querySelector('.type-select');
        if (select) {
          select.dispatchEvent(evt);
        }
      }
    }
    
    container.appendChild(block);
  });
  
// Guardar copia global de la config original (respaldo)
questionsConfig = data.questionsConfig || [];
window.questionsConfig = questionsConfig;

// Generar la preview directamente desde la config del servidor
generatePreviewFromConfig({
  logoConfig: data.logoConfig || {},
  titleConfig: data.titleConfig || {},
  descriptionConfig: data.descriptionConfig || {},
  thanksConfig: data.thanksConfig || {},
  questionsConfig: data.questionsConfig || []
});

// (Opcional) Si más adelante quieres seguir forzando un re-render desde el DOM,
// puedes mantener un pequeño retry de seguridad. Pero en principio ya no hace falta.

}

    // Change theme color
    document.getElementById('themeColor').addEventListener('input', (e) => {
      document.documentElement.style.setProperty('--main-color', e.target.value);
    });
  </script>
</body>
</html>